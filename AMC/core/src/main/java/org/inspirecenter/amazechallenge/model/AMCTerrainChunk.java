/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Framework: http://nkasenides.github.io/athlos
  Generated on: 12-08-2021 11:56:05
  Athlos Project Editor, v0.1.0 BETA
-------------------------------------------------------------------------------- */

package org.inspirecenter.amazechallenge.model;

import java.util.HashMap;
import java.util.Map;
import com.nkasenides.athlos.proto.Transmittable;
import org.inspirecenter.amazechallenge.proto.*;
import com.nkasenides.athlos.model.*;
import com.raylabz.firestorm.annotation.FirestormObject;
import org.inspirecenter.amazechallenge.proto.AMCTerrainCellProto;
import org.inspirecenter.amazechallenge.proto.AMCTerrainChunkProto;

@FirestormObject
public class AMCTerrainChunk implements Transmittable<AMCTerrainChunkProto.Builder>, ITerrainChunk {
    private HashMap<String, AMCTerrainCell> cells = new HashMap<>();
    private String worldID;    
    private String id;    
    private MatrixPosition position;    

    public Map<String, AMCTerrainCell> getCells() {
        return cells;        
    }    
    
    public String getWorldID() {    
        return worldID;        
    }    
    
    public String getId() {    
        return id;        
    }    
    
    public MatrixPosition getPosition() {    
        return position;        
    }    
    

    public void setCells(HashMap<String, AMCTerrainCell> cells) {
        this.cells = cells;        
    }    
    
    public void setWorldID(String worldID) {    
        this.worldID = worldID;        
    }    
    
    public void setId(String id) {    
        this.id = id;        
    }    
    
    public void setPosition(MatrixPosition position) {    
        this.position = position;        
    }    
    

    @Override    
    public AMCTerrainChunkProto.Builder toProto() {
        AMCTerrainChunkProto.Builder protoBuilder = AMCTerrainChunkProto.newBuilder();
        HashMap<String, AMCTerrainCellProto> cellsMap = new HashMap<>();
        for (java.util.Map.Entry<String, AMCTerrainCell> entry : cells.entrySet()) {
            cellsMap.put(entry.getKey(), entry.getValue().toProto().build());            
        }        
        protoBuilder.setWorldID(worldID);        
        protoBuilder.setId(id);        
        protoBuilder.setPosition(position.toProto().build());        
        return protoBuilder;        
    }    
    
    public static final int SIZE = 30;



    /**
     * Utility method.
     * Returns the cellRow offset for a certain cellRow. Used in calculations for a chunk's starting cellRow and column.
     * Note: An offset for a negative position needs to be -1, in order to accommodate for the fact that negative positions start from -1 and not 0.
     * @param cellRow The cell row.
     * @return Returns an offset - will be -1 if the cellRow was negative, 0 if positive.
     */
    private static int getRowOffset(int cellRow) {
        return (cellRow < 0) ? -1 : 0;
    }

    /**
     * Utility method.
     * Returns the column offset for a certain column. Used in calculations for a chunk's starting row and column.
     * Note: An offset for a negative position needs to be -1, in order to accommodate for the fact that negative positions start from -1 and not 0.
     * @param cellCol The cell column.
     * @return Returns an offset - will be -1 if the column was negative, 0 if positive.
     */
    private static int getColOffset(int cellCol) {
        return (cellCol < 0) ? -1 : 0;
    }

    /**
     * Utility method.
     * Calculates the cellRow of a <b>Chunk</b> that contains a cell based on the cellRow of a cell.
     * @param cellRow The <b>cell</b> cellRow.
     * @return Returns the chunk cellRow.
     */
    public static int getChunkRow(int cellRow) {
        if (cellRow % AMCTerrainChunk.SIZE != 0) {
            return cellRow / AMCTerrainChunk.SIZE + getRowOffset(cellRow);
        }
        return cellRow / AMCTerrainChunk.SIZE;
    }

    /**
     * Utility method.
     * Calculates the column of a <b>Chunk</b> that contains a cell based on the column of a cell.
     * @param cellCol The <b>cell</b> column.
     * @return Returns the chunk column.
     */
    public static int getChunkCol(int cellCol) {
        if (cellCol % AMCTerrainChunk.SIZE != 0) {
            return cellCol / AMCTerrainChunk.SIZE + getColOffset(cellCol);
        }
        return cellCol / AMCTerrainChunk.SIZE;
    }

    /**
     * Utility method.
     * Finds the position of a chunk based on a cell's cellRow and cellCol.
     * @param cellRow The cell's cellRow.
     * @param cellCol The cell's column.
     * @return Returns a MatrixPosition2D.
     */
    public static MatrixPosition getChunkPosition(int cellRow, int cellCol) {
        return new MatrixPosition(getChunkRow(cellRow), getChunkCol(cellCol));
    }

    /**
     * Utility method.
     * Finds the cellPosition of a chunk based on a cell's row and column.
     * @param cellPosition The cell cellPosition.
     * @return Returns a MatrixPosition2D.
     */
    public static MatrixPosition getChunkPosition(MatrixPosition cellPosition) {
        return new MatrixPosition(getChunkRow(cellPosition.getRow()), getChunkCol(cellPosition.getCol()));
    }

    /**
     * Utility method.
     * Calculates the start cellRow of the <b>Chunk</b> that contains a cell with a specific cellRow.
     * @param cellRow The cell's cellRow.
     * @return Returns the starting cellRow of the chunk.
     */
    public static int getChunkStartRow(int cellRow) {
        return getChunkRow(cellRow) * AMCTerrainChunk.SIZE;
    }

    /**
     * Utility method.
     * Calculates a chunk's starting cell row based on the chunk's row.
     * @param chunkRow The chunk row.
     * @return Returns integer.
     */
    public static int getChunkStartRowFromChunkRow(int chunkRow) {
        return chunkRow * AMCTerrainChunk.SIZE;
    }

    /**
     * Utility method.
     * Calculates the last cellRow of the <b>Chunk</b> that contains a cell with a specific cellRow.
     * @param cellRow The cell's cellRow.
     * @return Returns the last cellRow of the chunk.
     */
    public static int getChunkLastRow(int cellRow) {
        return getChunkStartRow(cellRow) + AMCTerrainChunk.SIZE - 1;
    }

    /**
     * Utility method.
     * Calculates a chunk's last cell row based on the chunk's row.
     * @param chunkRow The chunk row.
     * @return Returns integer.
     */
    public static int getChunkLastRowFromChunkRow(int chunkRow) {
        return chunkRow * AMCTerrainChunk.SIZE + AMCTerrainChunk.SIZE - 1;
    }

    /**
     * Utility method.
     * Calculates the start column of the <b>Chunk</b> that contains a cell with a specific column.
     * @param cellCol The cell's column.
     * @return Returns the starting column of the chunk.
     */
    public static int getChunkStartCol(int cellCol) {
        return getChunkCol(cellCol) * AMCTerrainChunk.SIZE;
    }

    /**
     * Utility method.
     * Calculates a chunk's starting cell column based on the chunk's column.
     * @param chunkCol The chunk column.
     * @return Returns integer.
     */
    public static int getChunkStartColFromChunkCol(int chunkCol) {
        return chunkCol * AMCTerrainChunk.SIZE;
    }

    /**
     * Utility method.
     * Calculates the last column of the <b>Chunk</b> that contains a cell with a specific column.
     * @param cellCol The cell's column.
     * @return Returns the last column of the chunk.
     */
    public static int getChunkLastCol(int cellCol) {
        return getChunkStartCol(cellCol) + AMCTerrainChunk.SIZE - 1;
    }

    /**
     * Utility method.
     * Calculates a chunk's last cell column based on the chunk's column.
     * @param chunkCol The chunk column.
     * @return Returns integer.
     */
    public static int getChunkLastColFromChunkCol(int chunkCol) {
        return chunkCol * AMCTerrainChunk.SIZE + AMCTerrainChunk.SIZE - 1;
    }




}
