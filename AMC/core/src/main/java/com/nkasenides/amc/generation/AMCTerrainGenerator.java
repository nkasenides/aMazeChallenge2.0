/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Framework: http://nkasenides.github.io/athlos
  Generated on: 12-08-2021 11:56:05
  Athlos Project Editor, v0.1.0 BETA
-------------------------------------------------------------------------------- */

package com.nkasenides.amc.generation;

import com.nkasenides.amc.model.*;
import com.nkasenides.amc.proto.*;
import com.nkasenides.athlos.model.TerrainGenerator;
import com.raylabz.jsec.Hashing;
import com.nkasenides.athlos.exception.ChunkOutOfBoundsException;
import java.util.HashMap;
import java.util.UUID;

public class AMCTerrainGenerator extends TerrainGenerator<AMCWorld, AMCTerrainChunk, AMCTerrainCell>{

    //Imported from v1.
    public static final int SHAPE_ONLY_UPPER_SIDE = 0x1; // -
    public static final int SHAPE_ONLY_LOWER_SIDE = 0x2; // _
    public static final int SHAPE_ONLY_LEFT_SIDE  = 0x4; // |
    public static final int SHAPE_ONLY_RIGHT_SIDE = 0x8; //  |

    public AMCTerrainGenerator(AMCWorld world) {
        super(world);
    }

    //Imported from v1.
    public static int getGridCell(final Grid grid, final int row, final int col) throws IndexOutOfBoundsException {
        if(col < 0 || col > grid.getWidth()) throw new IndexOutOfBoundsException("col not in bounds [0, " + grid.getWidth() + ")");
        if(row < 0 || row > grid.getHeight()) throw new IndexOutOfBoundsException("row not in bounds [0, " + grid.getHeight() + ")");
        final char c = grid.getData().charAt(row * grid.getWidth() + col);
        return Integer.parseInt(Character.toString(c), 16);
    }

    protected final AMCTerrainCell generateCell(int cellRow, int cellCol) {
        final int gridCell = getGridCell(getWorld().getGrid(), cellRow, cellCol);
        final AMCTerrainCell cell = new AMCTerrainCell();
        cell.setPosition(new MatrixPosition(cellRow, cellCol));
        cell.setUpWall((gridCell & SHAPE_ONLY_UPPER_SIDE) != 0);
        cell.setDownWall((gridCell & SHAPE_ONLY_LOWER_SIDE) != 0);
        cell.setLeftWall((gridCell & SHAPE_ONLY_LEFT_SIDE) != 0);
        cell.setRightWall((gridCell & SHAPE_ONLY_RIGHT_SIDE) != 0);
        return cell;
    }    
    
    public final AMCTerrainCell acquireCell(final int cellRow, final int cellCol) throws ChunkOutOfBoundsException {
        if (world.cellIsInBounds(cellRow, cellCol)) {
            return generateCell(cellRow, cellCol);
        }
        else {
            throw new ChunkOutOfBoundsException(cellRow, cellCol);
        }
    }

    public final AMCTerrainChunk generateChunk(final int chunkRow, final int chunkCol) {

        final int chunkStartRow = AMCTerrainChunk.getChunkStartRowFromChunkRow(chunkRow);
        final int chunkLastRow = AMCTerrainChunk.getChunkLastRowFromChunkRow(chunkRow);
        final int chunkStartCol = AMCTerrainChunk.getChunkStartColFromChunkCol(chunkCol);
        final int chunkLastCol = AMCTerrainChunk.getChunkLastColFromChunkCol(chunkCol);

        AMCTerrainChunk chunk = new AMCTerrainChunk();
        chunk.setWorldID(world.getId());
        chunk.setId(UUID.randomUUID().toString());
        chunk.setPosition(new MatrixPosition(chunkRow, chunkCol));
        HashMap<String, AMCTerrainCell> cells = new HashMap<>();

        for (int c = chunkStartCol; c <= chunkLastCol; c++) {
            for (int r = chunkStartRow; r <= chunkLastRow; r++) {
                AMCTerrainCell cell = acquireCell(r, c);
                cells.put(Hashing.hash(r + "," + c), cell);
            }
        }
        chunk.setCells(cells);

        return chunk;
    }

}

