/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Framework: http://nkasenides.github.io/athlos
  Generated on: 12-08-2021 11:56:05
  Athlos Project Editor, v0.1.0 BETA
-------------------------------------------------------------------------------- */

package org.inspirecenter.amazechallenge.client;
import com.nkasenides.athlos.client.ServerlessGameClient;
import org.inspirecenter.amazechallenge.client.stubs.Stubs;
import org.inspirecenter.amazechallenge.model.*;
import org.inspirecenter.amazechallenge.proto.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.UUID;


public class SimulationClient extends ServerlessGameClient<AMCPartialStateProto, AMCGameSession, AMCWorldSession, AMCPlayer, AMCWorld, AMCEntityProto, AMCTerrainCellProto> {

    private final Simulation simulation;
    private final String name;
    private final String installationID = UUID.randomUUID().toString();

    private List<ChallengeProto> challenges;
    private ChallengeProto selectedChallenge;
    private AMCWorldSessionProto worldSession;
    private boolean codeSubmitted = false;
    private AMCPartialStateProto state;

    public SimulationClient(Simulation simulation, String name) {
        this.name = name;
        this.simulation = simulation;
        AMCPlayerProto player = AMCPlayerProto.newBuilder()
                .setId(name)
                .setName(name)
                .setEmail(name + "@simulation.com")
                .setCreatedOn(System.currentTimeMillis())
                .setPassword("")
                .setTeamID("")
                .setColor(selectRandomColor())
                .setIcon(selectRandomIcon())
                .build();
        setPlayer(player.toObject());
    }

    @Override
    protected void onStart() {
        new Thread(() -> {
            System.out.println("'" + name + "' started");
            listAvailableChallenges();
            selectChallenge();
            joinChallenge();
            submitCode();
        }).start();
    }

    private void listAvailableChallenges() {
        Stubs.listChallengesStub(this).sendAndWait(
                ListChallengesRequest.newBuilder()
                        .build(),
                listChallengesResponse -> {
                    if (listChallengesResponse.getStatus() == ListChallengesResponse.Status.OK) {
                        challenges = listChallengesResponse.getChallengesList();
                    }
                    else {
                        System.err.println("[ERROR]");
                        System.err.println(listChallengesResponse.getMessage());
                        stop();
                    }
                }
        );
    }

    private void selectChallenge() {
        if (challenges.size() == 0) {
            System.err.println("[ERROR]");
            System.err.println("No challenges available.");
            stop();
        }
        else {
            selectedChallenge = challenges.get(0);
        }
    }

    private void joinChallenge() {
        if (selectedChallenge == null) {
            System.err.println("[ERROR]");
            System.err.println("No selected challenge.");
            stop();
        }
        else {
            Stubs.joinChallengeStub(this).sendAndWait(
                    JoinChallengeRequest.newBuilder()
                            .setChallengeID(selectedChallenge.getId())
                            .setPlayer(getPlayer().toProto())
                            .setInstallationID(installationID)
                            .build(),
                    joinChallengeResponse -> {
                        if (joinChallengeResponse.getStatus() == JoinChallengeResponse.Status.OK) {
                             this.worldSession = joinChallengeResponse.getWorldSession();
                        }
                        else {
                            System.err.println("[ERROR]");
                            System.err.println(joinChallengeResponse.getMessage());
                            stop();
                        }
                    }
            );
        }
    }

    private void submitCode() {
        final String playerCode = Code.getRandomCode();
        Stubs.submitCodeStub(this).sendAndWait(
                SubmitCodeRequest.newBuilder()
                        .setCode(playerCode)
                        .setWorldSessionID(worldSession.getId())
                        .build(),
                submitCodeResponse -> {
                    if (submitCodeResponse.getStatus() == SubmitCodeResponse.Status.OK) {
                        System.out.println("'" + name + "' submitted code.");
                        this.codeSubmitted = true;
                        getState();
                    }
                    else {
                        System.err.println("[ERROR]");
                        System.err.println(submitCodeResponse.getMessage());
                    }
                }
        );
    }

    private void getState() {
        if (codeSubmitted) {
            Stubs.getStateStub(this).sendAndWait(
                    GetStateRequest.newBuilder()
                            .setWorldSessionID(worldSession.getId())
                            .build(),
                    getStateResponse -> {
                        if (getStateResponse.getStatus() == GetStateResponse.Status.OK) {
                            this.state = getStateResponse.getPartialState();
                            updateState();
                        }
                        else {
                            System.err.println("[ERROR]");
                            System.err.println(getStateResponse.getMessage());
                        }
                    }
            );
        }
    }

    private void updateState() {
        boolean[] gameEnd = new boolean[1];
        do {
            Stubs.updateStateStub(this).sendAndWait(
                    UpdateStateRequest.newBuilder()
                            .setWorldSessionID(worldSession.getId())
                            .build(),
                    updateStateResponse -> {
                        if (updateStateResponse.getStatus() == UpdateStateResponse.Status.OK) {
                            final AMCStateUpdateProto stateUpdate = updateStateResponse.getStateUpdate();
                            if (stateUpdate.getEventsList().contains(Audio.EVENT_LOSE_Audio) || stateUpdate.getEventsList().contains(Audio.EVENT_WIN_Audio)) {
                                gameEnd[0] = true;
                            }
                        }
                        else {
                            System.err.println("[ERROR]");
                            System.err.println(updateStateResponse.getMessage());
                        }
                    }
            );
        } while (!gameEnd[0]);
        leaveChallenge();
    }

    private void leaveChallenge() {
        Stubs.leaveChallengeStub(this).sendAndWait(
                LeaveChallengeRequest.newBuilder()
                        .setChallengeID(selectedChallenge.getId())
                        .setWorldSessionID(worldSession.getId())
                        .build(),
                leaveChallengeResponse -> {
                    if (leaveChallengeResponse.getStatus() == LeaveChallengeResponse.Status.OK) {
                        System.out.println("'" + name + "' stopped.");
                        stop();
                    }
                    else {
                        System.err.println("[ERROR]");
                        System.err.println(leaveChallengeResponse.getMessage());
                    }
                }
        );
    }

    private AmazeColor selectRandomColor() {
        Random random = new Random();
        final int randomIndex = random.nextInt(AmazeColor.values().length);
        if (AmazeColor.values()[randomIndex] == AmazeColor.UNRECOGNIZED) {
            return AmazeColor.BLACK_AmazeColor;
        }
        else {
            return AmazeColor.values()[randomIndex];
        }
    }

    private AmazeIcon selectRandomIcon() {
        Random random = new Random();
        final int randomIndex = random.nextInt(AmazeIcon.values().length);
        if (AmazeIcon.values()[randomIndex] == AmazeIcon.UNRECOGNIZED) {
            return AmazeIcon.ICON_1_AmazeIcon;
        }
        else {
            return AmazeIcon.values()[randomIndex];
        }
    }

}
