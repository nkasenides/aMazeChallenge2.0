/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Framework: http://nkasenides.github.io/athlos
  Generated on: 17-08-2021 12:37:25
  Athlos Project Editor, v0.1.0 BETA
-------------------------------------------------------------------------------- */

package org.inspirecenter.amazechallenge.service;
import com.google.appengine.api.memcache.MemcacheService;
import com.google.appengine.api.memcache.MemcacheServiceFactory;
import com.google.appengine.api.taskqueue.Queue;
import com.google.appengine.api.taskqueue.QueueFactory;
import com.google.appengine.api.taskqueue.TaskOptions;
import org.inspirecenter.amazechallenge.model.*;
import org.inspirecenter.amazechallenge.persistence.DBManager;
import org.inspirecenter.amazechallenge.proto.*;
import com.nkasenides.athlos.backend.AthlosService;
import org.inspirecenter.amazechallenge.auth.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.UUID;

public class JoinChallenge implements AthlosService<JoinChallengeRequest, JoinChallengeResponse> {

    @Override    
    public JoinChallengeResponse serve(JoinChallengeRequest request, Object... additionalParams) {

        final AMCPlayerProto player = request.getPlayer();
        final String installationID = request.getInstallationID();

        //Installation ID must not be empty:
        if (installationID.isEmpty()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER")
                    .build();
        }

        //Player name must not be empty:
        if (player.getName().isEmpty()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER_NAME")
                    .build();
        }

        //Player name must contain only letters, numbers and underscores:
        if (!player.getName().matches("^[a-zA-Z0-9_]*$")) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER_NAME")
                    .build();
        }

        //Player email must not be empty:
        if (player.getEmail().isEmpty()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER_EMAIL")
                    .build();
        }

        //Player email must be valid:
        String emailRegex = "^[\\w!#$%&'*+/=?`{|}~^-]+(?:\\.[\\w!#$%&'*+/=?`{|}~^-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,6}$";
        if (!player.getEmail().matches(emailRegex)) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER_EMAIL")
                    .build();
        }

        //Challenge ID must not be empty:
        final String challengeID = request.getChallengeID();
        if (challengeID.isEmpty()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_CHALLENGE)
                    .setMessage("INVALID_CHALLENGE_ID")
                    .build();
        }

        //Challenge must exist:
        final Challenge challenge = DBManager.challenge.get(challengeID);
        if (challenge == null) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_CHALLENGE)
                    .setMessage("INVALID_CHALLENGE_ID")
                    .build();
        }

        //Challenge must be started:
        if (challenge.getStartTime() > System.currentTimeMillis()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.CHALLENGE_NOT_STARTED)
                    .setMessage("CHALLENGE_NOT_STARTED")
                    .build();
        }

        //Challenge must not be over:
        if (challenge.getEndTime() < System.currentTimeMillis()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.CHALLENGE_OVER)
                    .setMessage("CHALLENGE_OVER")
                    .build();
        }

        final Collection<AMCWorldSession> challengeSessions = DBManager.worldSession.listForWorld(challengeID);

        //Challenge must have empty slots:
        if (challengeSessions.size() >= challenge.getMaxActivePlayers()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.CHALLENGE_FULL)
                    .setMessage("CHALLENGE_FULL")
                    .build();
        }

        AMCWorldSession worldSession = null;
        boolean newSession = false;

        //If the player has already joined and has provided a correct installation ID, return the existing world session:
        for (AMCWorldSession challengeSession : challengeSessions) {
            if (installationID.equals(challengeSession.getInstallationID()) && player.getId().equalsIgnoreCase(challengeSession.getPlayerID())) {
                worldSession = challengeSession;
                break;
            }
        }

        //Challenge must not have a player with the same name, but different installation ID:
        for (AMCWorldSession challengeSession : challengeSessions) {
            if (challengeSession.getPlayerID().equalsIgnoreCase(player.getName()) && !installationID.equals(challengeSession.getInstallationID())) {
                return JoinChallengeResponse.newBuilder()
                        .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                        .setMessage("PLAYER_NAME_EXISTS")
                        .build();
            }
        }

        synchronized (JoinChallenge.class) {
            //If the player did not exist, create a new world session:
            if (worldSession == null) {
                newSession = true;
                worldSession = new AMCWorldSession();
                worldSession.setCameraPosition(challenge.getGrid().getStartingPosition());
                worldSession.setWorldID(challengeID);
                worldSession.setCode("");
                worldSession.setHealth(new Health());
                worldSession.setCreatedOn(System.currentTimeMillis());
                worldSession.setExpiresOn(System.currentTimeMillis() + 3600 * 24); //24h
                worldSession.setIpAddress((String) additionalParams[0]);
                worldSession.setPlayerID(player.getName());
                worldSession.setPoints(0);
                worldSession.setInstallationID(installationID);
                worldSession.setId(AMCWorldSession.getWorldSessionID(player.getId(), challengeID));
            }

            final MemcacheService memcache = MemcacheServiceFactory.getMemcacheService();
            Game game = (Game) memcache.get("game_" + worldSession.getWorldID());

            //If the game does not exist, create and store it in  memcache:
            if (game == null) {
                game = new Game();
                game.setId("game_" + worldSession.getWorldID());
                game.setChallengeID(challengeID);
                game.addPlayer(player.toObject(), worldSession);
                game.getPlayerWorldSessions().put(worldSession.getId(), worldSession);
                memcache.put(game.getId(), game);

                //Start the runtime task:
                final Queue queue = QueueFactory.getDefaultQueue();
                RuntimeRequest runtimeRequest = RuntimeRequest.newBuilder()
                        .setChallengeID(challengeID)
                        .setGameID(game.getId())
                        .setAdminKey(DBManager.adminKey.get().getId())
                        .build();

                TaskOptions taskOptions = TaskOptions.Builder
                        .withUrl("/admin/runtime")
                        .payload(runtimeRequest.toByteArray())
                        .method(TaskOptions.Method.POST);

                queue.add(taskOptions);
            }

            //If the game exists, just add the player:
            else {
                final int numOfPlayers = game.getActivePlayers().size() + game.getWaitingPlayers().size() + game.getQueuedPlayers().size();

                game.addPlayer(player.toObject(), worldSession);
                game.getPlayerWorldSessions().put(worldSession.getId(), worldSession);
                memcache.put(game.getId(), game);

                //If this is the first player to join, start the task queue:
                if (numOfPlayers == 0) {
                    //Start the runtime task:
                    final Queue queue = QueueFactory.getDefaultQueue();
                    RuntimeRequest runtimeRequest = RuntimeRequest.newBuilder()
                            .setChallengeID(challengeID)
                            .setGameID(game.getId())
                            .setAdminKey(DBManager.adminKey.get().getId())
                            .build();

                    TaskOptions taskOptions = TaskOptions.Builder
                            .withUrl("/admin/runtime")
                            .payload(runtimeRequest.toByteArray())
                            .method(TaskOptions.Method.POST);

                    queue.add(taskOptions);
                }
            }

            //If this is a new session, create it in the DB:
            if (newSession) {
                DBManager.worldSession.create(worldSession);
            }
        }

        return JoinChallengeResponse.newBuilder()
                .setStatus(JoinChallengeResponse.Status.OK)
                .setMessage("OK")
                .setChallenge(challenge.toProto())
                .setWorldSession(worldSession.toProto())
                .build();


    }

    public static String getPlayerEntityID(String playerID, String worldID) {
        return playerID + "_" + worldID;
    }

    
}

