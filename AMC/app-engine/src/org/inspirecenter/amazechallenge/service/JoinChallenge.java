/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Framework: http://nkasenides.github.io/athlos
  Generated on: 17-08-2021 12:37:25
  Athlos Project Editor, v0.1.0 BETA
-------------------------------------------------------------------------------- */

package org.inspirecenter.amazechallenge.service;
import com.google.appengine.api.memcache.MemcacheService;
import com.google.appengine.api.memcache.MemcacheServiceFactory;
import com.google.appengine.api.taskqueue.Queue;
import com.google.appengine.api.taskqueue.QueueFactory;
import com.google.appengine.api.taskqueue.TaskOptions;
import io.ably.lib.realtime.AblyRealtime;
import io.ably.lib.realtime.Channel;
import io.ably.lib.types.AblyException;
import org.inspirecenter.amazechallenge.model.*;
import org.inspirecenter.amazechallenge.persistence.DBManager;
import org.inspirecenter.amazechallenge.proto.*;
import com.nkasenides.athlos.backend.AthlosService;
import org.inspirecenter.amazechallenge.auth.*;

import java.util.*;

public class JoinChallenge implements AthlosService<JoinChallengeRequest, JoinChallengeResponse> {

//    private static AblyRealtime ably;

//    static {
//        try {
//            ably = new AblyRealtime("KC5T5A.vG4G5Q:kpD9gGw44EERYqI-");
//        } catch (AblyException e) {
//            e.printStackTrace();
//        }
//    }

    @Override    
    public JoinChallengeResponse serve(JoinChallengeRequest request, Object... additionalParams) {

        final AMCPlayerProto player = request.getPlayer();
        final String installationID = request.getInstallationID();

        //Installation ID must not be empty:
        if (installationID.isEmpty()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER")
                    .build();
        }

        //Player name must not be empty:
        if (player.getName().isEmpty()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER_NAME")
                    .build();
        }

        //Player name must contain only letters, numbers and underscores:
        if (!player.getName().matches("^[a-zA-Z0-9_]*$")) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER_NAME")
                    .build();
        }

        //Player email must not be empty:
        if (player.getEmail().isEmpty()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER_EMAIL")
                    .build();
        }

        //Player email must be valid:
        String emailRegex = "^[\\w!#$%&'*+/=?`{|}~^-]+(?:\\.[\\w!#$%&'*+/=?`{|}~^-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,6}$";
        if (!player.getEmail().matches(emailRegex)) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER_EMAIL")
                    .build();
        }

        //Challenge ID must not be empty:
        final String challengeID = request.getChallengeID();
        if (challengeID.isEmpty()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_CHALLENGE)
                    .setMessage("INVALID_CHALLENGE_ID")
                    .build();
        }

        //Challenge must exist:
        final Challenge challenge = DBManager.challenge.get(challengeID);
        if (challenge == null) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_CHALLENGE)
                    .setMessage("INVALID_CHALLENGE_ID")
                    .build();
        }

        //Challenge must be started:
        if (challenge.getStartTime() > System.currentTimeMillis()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.CHALLENGE_NOT_STARTED)
                    .setMessage("CHALLENGE_NOT_STARTED")
                    .build();
        }

        //Challenge must not be over:
        if (challenge.getEndTime() < System.currentTimeMillis()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.CHALLENGE_OVER)
                    .setMessage("CHALLENGE_OVER")
                    .build();
        }

        final Collection<AMCWorldSession> challengeSessions = DBManager.worldSession.listForWorld(challengeID);

        //Challenge must have empty slots:
        if (challengeSessions.size() >= challenge.getMaxActivePlayers()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.CHALLENGE_FULL)
                    .setMessage("CHALLENGE_FULL")
                    .build();
        }

        AMCWorldSession worldSession = null;
        boolean newSession = false;

        //If the player has already joined and has provided a correct installation ID, return the existing world session:
        for (AMCWorldSession challengeSession : challengeSessions) {
            if (installationID.equals(challengeSession.getInstallationID()) && player.getId().equalsIgnoreCase(challengeSession.getPlayerID())) {
                worldSession = challengeSession;
                break;
            }
        }

        //Challenge must not have a player with the same name, but different installation ID:
        for (AMCWorldSession challengeSession : challengeSessions) {
            if (challengeSession.getPlayerID().equalsIgnoreCase(player.getName()) && !installationID.equals(challengeSession.getInstallationID())) {
                return JoinChallengeResponse.newBuilder()
                        .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                        .setMessage("PLAYER_NAME_EXISTS")
                        .build();
            }
        }

        synchronized (JoinChallenge.class) {
            //If the player did not exist, create a new world session:
            if (worldSession == null) {
                newSession = true;
                worldSession = new AMCWorldSession();
                worldSession.setCameraPosition(challenge.getGrid().getStartingPosition());
                worldSession.setWorldID(challengeID);
                worldSession.setCode("");
                worldSession.setHealth(new Health());
                worldSession.setCreatedOn(System.currentTimeMillis());
                worldSession.setExpiresOn(System.currentTimeMillis() + 3600 * 24); //24h
                worldSession.setIpAddress((String) additionalParams[0]);
                worldSession.setPlayerID(player.getName());
                worldSession.setPoints(0);
                worldSession.setInstallationID(installationID);
                worldSession.setId(AMCWorldSession.getWorldSessionID(player.getId(), challengeID));
            }

            final MemcacheService memcache = MemcacheServiceFactory.getMemcacheService();
            Game game = (Game) memcache.get("game_" + worldSession.getWorldID());

            //If the game does not exist, create and store it in  memcache:
            if (game == null) {
                game = new Game();
                game.setId("game_" + worldSession.getWorldID());
                game.setChallengeID(challengeID);
                game.addPlayer(player.toObject(), worldSession);
                game.getPlayerWorldSessions().put(worldSession.getId(), worldSession);

                //Update client states:
//                for (String activePlayerID : game.getActivePlayers()) {
//                    AMCWorldSession activePlayerSession = game.getPlayerWorldSessions().get(activePlayerID);
//                    Channel channel = ably.channels.get("stateUpdate-" + activePlayerID);
//                    try {
//
//                        //Compose state:
//                        final List<PickableEntity> pickables = game.getPickables();
//                        final Map<String, PlayerEntity> playerEntities = game.getPlayerEntities();
//
//                        final AMCPartialStateProto.Builder builder = AMCPartialStateProto.newBuilder();
//
//                        //Pickable entities:
//                        for (PickableEntity pickable : pickables) {
//                            builder.putEntities(pickable.getId(), pickable.toGenericProto().build());
//                        }
//
//                        //Player entities:
//                        for (Map.Entry<String, PlayerEntity> entry : playerEntities.entrySet()) {
//                            builder.putEntities(entry.getKey(), entry.getValue().toGenericProto().build());
//                        }
//
//                        //Players:
//                        for (Map.Entry<String, AMCPlayer> entry : game.getAllPlayers().entrySet()) {
//                            builder.putPlayers(entry.getKey(), entry.getValue().toProto().build());
//                        }
//
//                        //World sessions:
//                        for (Map.Entry<String, AMCWorldSession> entry : game.getPlayerWorldSessions().entrySet()) {
//                            builder.putWorldSessions(entry.getKey(), entry.getValue().toProto().build());
//                        }
//
//                        //Handle events:
//                        final HashMap<Long, Audio> playerEvents = game.getPlayerEvents(activePlayerSession.getPlayerID());
//                        Vector<Audio> dispatchedEvents = new Vector<>(playerEvents.values());
//                        game.clearAllPlayerEvents(activePlayerSession.getPlayerID());
//                        memcache.put(game.getId(), game);
//
//                        //Retrieve the partial state:
//                        builder
//                                .setTimestamp(System.currentTimeMillis())
//                                .setWorldSession(activePlayerSession.toProto())
//                                .addAllActivePlayers(game.getActivePlayers())
//                                .addAllQueuedPlayers(game.getQueuedPlayers())
//                                .addAllWaitingPlayers(game.getWaitingPlayers())
//                                .build();
//
//                        final UpdateStateResponse updateStateResponse = UpdateStateResponse.newBuilder()
//                                .setStatus(UpdateStateResponse.Status.OK)
//                                .setMessage("OK")
//                                .setStateUpdate(AMCStateUpdateProto.newBuilder()
//                                        .setPartialState(builder.build())
//                                        .setTimestamp(System.currentTimeMillis())
//                                        .setWorldSessionID(activePlayerSession.getId())
//                                        .addAllEvents(dispatchedEvents)
//                                        .build()
//                                )
//                                .build();
//
//
//                        //Send message:
//                        channel.publish("stateUpdate", updateStateResponse.toByteArray());
//
//                    } catch (AblyException e) {
//                        e.printStackTrace();
//                    }
//                }

                memcache.put(game.getId(), game);

                //Start the runtime task:
                final Queue queue = QueueFactory.getDefaultQueue();
                RuntimeRequest runtimeRequest = RuntimeRequest.newBuilder()
                        .setChallengeID(challengeID)
                        .setGameID(game.getId())
                        .setAdminKey(DBManager.adminKey.get().getId())
                        .build();

                TaskOptions taskOptions = TaskOptions.Builder
                        .withUrl("/admin/runtime")
                        .payload(runtimeRequest.toByteArray())
                        .method(TaskOptions.Method.POST);

                queue.add(taskOptions);
            }

            //If the game exists, just add the player:
            else {
                final int numOfPlayers = game.getActivePlayers().size() + game.getWaitingPlayers().size() + game.getQueuedPlayers().size();

                game.addPlayer(player.toObject(), worldSession);
                game.getPlayerWorldSessions().put(worldSession.getId(), worldSession);

                //Update client states:
//                for (String activePlayerID : game.getActivePlayers()) {
//                    AMCWorldSession activePlayerSession = game.getPlayerWorldSessions().get(activePlayerID);
//                    Channel channel = ably.channels.get("stateUpdate-" + activePlayerID);
//                    try {
//
//                        //Compose state:
//                        final List<PickableEntity> pickables = game.getPickables();
//                        final Map<String, PlayerEntity> playerEntities = game.getPlayerEntities();
//
//                        final AMCPartialStateProto.Builder builder = AMCPartialStateProto.newBuilder();
//
//                        //Pickable entities:
//                        for (PickableEntity pickable : pickables) {
//                            builder.putEntities(pickable.getId(), pickable.toGenericProto().build());
//                        }
//
//                        //Player entities:
//                        for (Map.Entry<String, PlayerEntity> entry : playerEntities.entrySet()) {
//                            builder.putEntities(entry.getKey(), entry.getValue().toGenericProto().build());
//                        }
//
//                        //Players:
//                        for (Map.Entry<String, AMCPlayer> entry : game.getAllPlayers().entrySet()) {
//                            builder.putPlayers(entry.getKey(), entry.getValue().toProto().build());
//                        }
//
//                        //World sessions:
//                        for (Map.Entry<String, AMCWorldSession> entry : game.getPlayerWorldSessions().entrySet()) {
//                            builder.putWorldSessions(entry.getKey(), entry.getValue().toProto().build());
//                        }
//
//                        //Handle events:
//                        final HashMap<Long, Audio> playerEvents = game.getPlayerEvents(activePlayerSession.getPlayerID());
//                        Vector<Audio> dispatchedEvents = new Vector<>(playerEvents.values());
//                        game.clearAllPlayerEvents(activePlayerSession.getPlayerID());
//                        memcache.put(game.getId(), game);
//
//                        //Retrieve the partial state:
//                        builder
//                                .setTimestamp(System.currentTimeMillis())
//                                .setWorldSession(activePlayerSession.toProto())
//                                .addAllActivePlayers(game.getActivePlayers())
//                                .addAllQueuedPlayers(game.getQueuedPlayers())
//                                .addAllWaitingPlayers(game.getWaitingPlayers())
//                                .build();
//
//                        final UpdateStateResponse updateStateResponse = UpdateStateResponse.newBuilder()
//                                .setStatus(UpdateStateResponse.Status.OK)
//                                .setMessage("OK")
//                                .setStateUpdate(AMCStateUpdateProto.newBuilder()
//                                        .setPartialState(builder.build())
//                                        .setTimestamp(System.currentTimeMillis())
//                                        .setWorldSessionID(activePlayerSession.getId())
//                                        .addAllEvents(dispatchedEvents)
//                                        .build()
//                                )
//                                .build();
//
//
//                        //Send message:
//                        channel.publish("stateUpdate", updateStateResponse.toByteArray());
//
//                    } catch (AblyException e) {
//                        e.printStackTrace();
//                    }
//                }

                memcache.put(game.getId(), game);

                //If this is the first player to join, start the task queue:
                if (numOfPlayers == 0) {
                    //Start the runtime task:
                    final Queue queue = QueueFactory.getDefaultQueue();
                    RuntimeRequest runtimeRequest = RuntimeRequest.newBuilder()
                            .setChallengeID(challengeID)
                            .setGameID(game.getId())
                            .setAdminKey(DBManager.adminKey.get().getId())
                            .build();

                    TaskOptions taskOptions = TaskOptions.Builder
                            .withUrl("/admin/runtime")
                            .payload(runtimeRequest.toByteArray())
                            .method(TaskOptions.Method.POST);

                    queue.add(taskOptions);
                }
            }

            //If this is a new session, create it in the DB:
            if (newSession) {
                DBManager.worldSession.create(worldSession);
            }
        }

        return JoinChallengeResponse.newBuilder()
                .setStatus(JoinChallengeResponse.Status.OK)
                .setMessage("OK")
                .setChallenge(challenge.toProto())
                .setWorldSession(worldSession.toProto())
                .build();


    }

    public static String getPlayerEntityID(String playerID, String worldID) {
        return playerID + "_" + worldID;
    }

    
}

