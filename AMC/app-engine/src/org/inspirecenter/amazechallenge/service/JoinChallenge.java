/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Framework: http://nkasenides.github.io/athlos
  Generated on: 17-08-2021 12:37:25
  Athlos Project Editor, v0.1.0 BETA
-------------------------------------------------------------------------------- */

package org.inspirecenter.amazechallenge.service;
import com.google.appengine.api.memcache.MemcacheService;
import com.google.appengine.api.memcache.MemcacheServiceFactory;
import org.inspirecenter.amazechallenge.model.*;
import org.inspirecenter.amazechallenge.persistence.DBManager;
import org.inspirecenter.amazechallenge.proto.AMCPartialStateProto;
import org.inspirecenter.amazechallenge.proto.AMCPlayerProto;
import com.nkasenides.athlos.backend.AthlosService;
import org.inspirecenter.amazechallenge.proto.JoinChallengeRequest;
import org.inspirecenter.amazechallenge.auth.*;
import org.inspirecenter.amazechallenge.proto.JoinChallengeResponse;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.UUID;

public class JoinChallenge implements AthlosService<JoinChallengeRequest, JoinChallengeResponse> {

    @Override    
    public JoinChallengeResponse serve(JoinChallengeRequest request, Object... additionalParams) {

        final AMCPlayerProto player = request.getPlayer();

        //Player name must not be empty:
        if (player.getName().isEmpty()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER_NAME")
                    .build();
        }

        //Player name must contain only letters, numbers and underscores:
        if (!player.getName().matches("^[a-zA-Z0-9_]*$")) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER_NAME")
                    .build();
        }

        //Player email must not be empty:
        if (player.getEmail().isEmpty()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER_EMAIL")
                    .build();
        }

        //Player email must be valid:
        String emailRegex = "^[\\w!#$%&'*+/=?`{|}~^-]+(?:\\.[\\w!#$%&'*+/=?`{|}~^-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,6}$";
        if (!player.getEmail().matches(emailRegex)) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                    .setMessage("INVALID_PLAYER_EMAIL")
                    .build();
        }

        //Challenge ID must not be empty:
        final String challengeID = request.getChallengeID();
        if (challengeID.isEmpty()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_CHALLENGE)
                    .setMessage("INVALID_CHALLENGE_ID")
                    .build();
        }

        //Challenge must exist:
        final Challenge challenge = DBManager.challenge.get(challengeID);
        if (challenge == null) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.INVALID_CHALLENGE)
                    .setMessage("INVALID_CHALLENGE_ID")
                    .build();
        }

        //Challenge must be started:
        if (challenge.getStartTime() > System.currentTimeMillis()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.CHALLENGE_NOT_STARTED)
                    .setMessage("CHALLENGE_NOT_STARTED")
                    .build();
        }

        //Challenge must not be over:
        if (challenge.getEndTime() < System.currentTimeMillis()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.CHALLENGE_OVER)
                    .setMessage("CHALLENGE_OVER")
                    .build();
        }

        final Collection<AMCWorldSession> challengeSessions = DBManager.worldSession.listForWorld(challengeID);

        //Challenge must have empty slots:
        if (challengeSessions.size() >= challenge.getMaxActivePlayers()) {
            return JoinChallengeResponse.newBuilder()
                    .setStatus(JoinChallengeResponse.Status.CHALLENGE_FULL)
                    .setMessage("CHALLENGE_FULL")
                    .build();
        }

        //Challenge must not have a player with the same name:
        for (AMCWorldSession challengeSession : challengeSessions) {
            if (challengeSession.getPlayerID().equalsIgnoreCase(player.getName())) {
                return JoinChallengeResponse.newBuilder()
                        .setStatus(JoinChallengeResponse.Status.INVALID_PLAYER)
                        .setMessage("PLAYER_NAME_EXISTS")
                        .build();
            }
        }

        //Create world session:
        AMCWorldSession worldSession = new AMCWorldSession();
        worldSession.setCameraPosition(challenge.getGrid().getStartingPosition());
        worldSession.setWorldID(challengeID);
        worldSession.setCode("");
        worldSession.setHealth(new Health());
        worldSession.setCreatedOn(System.currentTimeMillis());
        worldSession.setExpiresOn(System.currentTimeMillis() + 3600*24); //24h
        worldSession.setIpAddress((String) additionalParams[0]);
        worldSession.setPlayerID(player.getName());
        worldSession.setPoints(0);

        //Create the player entity:
        PlayerEntity playerEntity = new PlayerEntity();
        playerEntity.setPlayerID(player.getName());
        playerEntity.setWorldID(worldSession.getWorldID());
        playerEntity.setDirection(challenge.getGrid().getStartingDirection());
        playerEntity.setId(getPlayerEntityID(player.getName(), worldSession.getWorldID()));
        playerEntity.setPosition(challenge.getGrid().getStartingPosition());
        playerEntity.setAreaOfInterest(30);

        final MemcacheService memcache = MemcacheServiceFactory.getMemcacheService();

        //If this is the first player joining this challenge, initialize the game state:
        final Collection<AMCWorldSession> worldSessionsForWorld = DBManager.worldSession.listForWorld(worldSession.getWorldID());
        if (worldSessionsForWorld.isEmpty()) {
            Game game = new Game();
            game.setId("game_" + worldSession.getWorldID());
            game.setChallengeID(challengeID);
            game.addPlayer(player.toObject(), worldSession);
            memcache.put(game.getId(), game);
        }
        else {
            Game game = (Game) memcache.get("game_" + worldSession.getWorldID());
            game.addPlayer(player.toObject(), worldSession);
            memcache.put(game.getId(), game);
        }

        DBManager.worldSession.create(worldSession);

        return JoinChallengeResponse.newBuilder()
                .setStatus(JoinChallengeResponse.Status.OK)
                .setMessage("OK")
                .setChallenge(challenge.toProto())
                .setWorldSession(worldSession.toProto())
                .build();


    }

    public static String getPlayerEntityID(String playerID, String worldID) {
        return playerID + "_" + worldID;
    }

    
}

