/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Framework: http://nkasenides.github.io/athlos
  Generated on: 17-09-2021 11:38:42
  Athlos Project Editor, v0.1.0 BETA
-------------------------------------------------------------------------------- */

package org.inspirecenter.amazechallenge.service;
import com.google.appengine.api.memcache.MemcacheService;
import com.google.appengine.api.memcache.MemcacheServiceFactory;
import com.nkasenides.athlos.backend.AthlosService;
import io.ably.lib.realtime.AblyRealtime;
import io.ably.lib.realtime.Channel;
import io.ably.lib.types.AblyException;
import org.inspirecenter.amazechallenge.model.*;
import org.inspirecenter.amazechallenge.persistence.DBManager;
import org.inspirecenter.amazechallenge.persistence.KeyUtils;
import org.inspirecenter.amazechallenge.proto.*;
import org.inspirecenter.amazechallenge.auth.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;

public class LeaveChallenge implements AthlosService<LeaveChallengeRequest, LeaveChallengeResponse> {

//    private static AblyRealtime ably;

//    static {
//        try {
//            ably = new AblyRealtime("KC5T5A.vG4G5Q:kpD9gGw44EERYqI-");
//        } catch (AblyException e) {
//            e.printStackTrace();
//        }
//    }

    @Override    
    public LeaveChallengeResponse serve(LeaveChallengeRequest request, Object... additionalParams) {

        final String challengeID = request.getChallengeID();
        final String worldSessionID = request.getWorldSessionID();

        //Check world session ID:
        if (worldSessionID.isEmpty()) {
            return LeaveChallengeResponse.newBuilder()
                    .setStatus(LeaveChallengeResponse.Status.INVALID_WORLD_SESSION)
                    .setMessage("INVALID_WORLD_SESSION")
                    .build();
        }

        //Check challenge ID:
        if (challengeID.isEmpty()) {
            return LeaveChallengeResponse.newBuilder()
                    .setStatus(LeaveChallengeResponse.Status.INVALID_CHALLENGE)
                    .setMessage("INVALID_CHALLENGE")
                    .build();
        }

        //Verify world session:
        final AMCWorldSession worldSession = Auth.verifyWorldSessionID(worldSessionID);
        if (worldSession == null) {
            return LeaveChallengeResponse.newBuilder()
                    .setStatus(LeaveChallengeResponse.Status.INVALID_WORLD_SESSION)
                    .setMessage("INVALID_WORLD_SESSION")
                    .build();
        }

        //Verify challenge:
        final Challenge challenge = DBManager.challenge.get(challengeID);
        if (challenge == null) {
            return LeaveChallengeResponse.newBuilder()
                    .setStatus(LeaveChallengeResponse.Status.INVALID_CHALLENGE)
                    .setMessage("INVALID_CHALLENGE")
                    .build();
        }

        final MemcacheService memcache = MemcacheServiceFactory.getMemcacheService();

        //Remove the player from the game:
        final String playerID = worldSession.getPlayerID();
        final String gameID = "game_" + worldSession.getWorldID();

        memcache.delete(Runtime.getMazeSolverStateKey(gameID, playerID)); // reset algorithm's state
        memcache.delete(KeyUtils.getCodeKey(challenge.getId(), playerID)); // reset submitted code

        final Object o = memcache.get(gameID);
        if (o == null) {
            System.err.println("Invalid game");
            return LeaveChallengeResponse.newBuilder()
                    .setStatus(LeaveChallengeResponse.Status.CANNOT_LEAVE_CHALLENGE)
                    .setMessage("CANNOT_LEAVE_CHALLENGE")
                    .build();
        }

        Game game = (Game) o;

        game.resetPlayerById(playerID);
        game.clearAllPlayerEvents(playerID);

        //Update client states:
//        for (String activePlayerID : game.getAllPlayers().keySet()) {
//            AMCWorldSession activePlayerSession = game.getPlayerWorldSessions().get(activePlayerID);
//            Channel channel = ably.channels.get("stateUpdate-" + activePlayerID);
//            try {
//
//                //Compose state:
//                final List<PickableEntity> pickables = game.getPickables();
//                final Map<String, PlayerEntity> playerEntities = game.getPlayerEntities();
//
//                final AMCPartialStateProto.Builder builder = AMCPartialStateProto.newBuilder();
//
//                //Pickable entities:
//                for (PickableEntity pickable : pickables) {
//                    builder.putEntities(pickable.getId(), pickable.toGenericProto().build());
//                }
//
//                //Player entities:
//                for (Map.Entry<String, PlayerEntity> entry : playerEntities.entrySet()) {
//                    builder.putEntities(entry.getKey(), entry.getValue().toGenericProto().build());
//                }
//
//                //Players:
//                for (Map.Entry<String, AMCPlayer> entry : game.getAllPlayers().entrySet()) {
//                    builder.putPlayers(entry.getKey(), entry.getValue().toProto().build());
//                }
//
//                //World sessions:
//                for (Map.Entry<String, AMCWorldSession> entry : game.getPlayerWorldSessions().entrySet()) {
//                    builder.putWorldSessions(entry.getKey(), entry.getValue().toProto().build());
//                }
//
//                //Handle events:
//                final HashMap<Long, Audio> playerEvents = game.getPlayerEvents(activePlayerSession.getPlayerID());
//                Vector<Audio> dispatchedEvents = new Vector<>(playerEvents.values());
//                game.clearAllPlayerEvents(activePlayerSession.getPlayerID());
//                memcache.put(game.getId(), game);
//
//                //Retrieve the partial state:
//                builder
//                        .setTimestamp(System.currentTimeMillis())
//                        .setWorldSession(activePlayerSession.toProto())
//                        .addAllActivePlayers(game.getActivePlayers())
//                        .addAllQueuedPlayers(game.getQueuedPlayers())
//                        .addAllWaitingPlayers(game.getWaitingPlayers())
//                        .build();
//
//                final UpdateStateResponse updateStateResponse = UpdateStateResponse.newBuilder()
//                        .setStatus(UpdateStateResponse.Status.OK)
//                        .setMessage("OK")
//                        .setStateUpdate(AMCStateUpdateProto.newBuilder()
//                                .setPartialState(builder.build())
//                                .setTimestamp(System.currentTimeMillis())
//                                .setWorldSessionID(activePlayerSession.getId())
//                                .addAllEvents(dispatchedEvents)
//                                .build()
//                        )
//                        .build();
//
//
//                //Send message:
//                channel.publish("stateUpdate", updateStateResponse.toByteArray());
//
//            } catch (AblyException e) {
//                e.printStackTrace();
//            }
//        }

        memcache.put(game.getId(), game);

        System.out.println("Player reset: " + playerID);

        return LeaveChallengeResponse.newBuilder()
                .setStatus(LeaveChallengeResponse.Status.OK)
                .setMessage("OK")
                .build();

    }    
    
}

