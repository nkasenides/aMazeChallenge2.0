/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Framework: http://nkasenides.github.io/athlos
  Generated on: 31-08-2021 16:49:49
  Athlos Project Editor, v0.1.0 BETA
-------------------------------------------------------------------------------- */

package org.inspirecenter.amazechallenge.service;
import com.google.appengine.api.memcache.MemcacheService;
import com.google.appengine.api.memcache.MemcacheServiceFactory;
import com.google.appengine.api.taskqueue.Queue;
import com.google.appengine.api.taskqueue.QueueFactory;
import com.google.appengine.api.taskqueue.TaskOptions;
import com.nkasenides.athlos.backend.AthlosService;
import io.ably.lib.realtime.AblyRealtime;
import io.ably.lib.realtime.Channel;
import io.ably.lib.types.AblyException;
import org.inspirecenter.amazechallenge.algorithms.InterpretedMazeSolver;
import org.inspirecenter.amazechallenge.algorithms.MazeSolver;
import org.inspirecenter.amazechallenge.controller.RuntimeController;
import org.inspirecenter.amazechallenge.model.*;
import org.inspirecenter.amazechallenge.persistence.DBManager;
import org.inspirecenter.amazechallenge.persistence.KeyUtils;
import org.inspirecenter.amazechallenge.proto.*;
import org.inspirecenter.amazechallenge.auth.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;

public class Runtime implements AthlosService<RuntimeRequest, RuntimeResponse> {

    private static final long ONE_SECOND = 1000L;

    private final MemcacheService memcache = MemcacheServiceFactory.getMemcacheService();
    private static AblyRealtime ably;

    static {
        try {
            ably = new AblyRealtime("KC5T5A.vG4G5Q:kpD9gGw44EERYqI-");
        } catch (AblyException e) {
            e.printStackTrace();
        }
    }

    @Override
    public RuntimeResponse serve(RuntimeRequest request, Object... additionalParams) {

        System.out.println("~~~~~ Runtime exec ~~~~~");
        long startTime = System.currentTimeMillis();

        final String adminKey = request.getAdminKey();
        final String challengeID = request.getChallengeID();
        final String gameID = request.getGameID();

        //Validate admin key:
        final AdminKey key = DBManager.adminKey.get();
        if (key == null) {
            System.err.println("INVALID_ADMIN_KEY");
            return RuntimeResponse.newBuilder()
                    .setStatus(RuntimeResponse.Status.INVALID_ADMIN_KEY)
                    .setMessage("INVALID_ADMIN_KEY")
                    .build();
        }

        if (!key.getId().equals(adminKey)) {
            System.err.println("INVALID_ADMIN_KEY");
            return RuntimeResponse.newBuilder()
                    .setStatus(RuntimeResponse.Status.INVALID_ADMIN_KEY)
                    .setMessage("INVALID_ADMIN_KEY")
                    .build();
        }

        final Challenge challenge = DBManager.challenge.get(challengeID);
        if (challenge == null) {
            System.err.println("INVALID_CHALLENGE");
            return RuntimeResponse.newBuilder()
                    .setStatus(RuntimeResponse.Status.INVALID_CHALLENGE)
                    .setMessage("INVALID_CHALLENGE")
                    .build();
        }

        final Object o = memcache.get(gameID);
        if (o == null) {
            System.err.println("INVALID_GAME");
            return RuntimeResponse.newBuilder()
                    .setStatus(RuntimeResponse.Status.INVALID_GAME)
                    .setMessage("INVALID_GAME")
                    .build();
        }

        Game game = (Game) o;

        synchronized (Runtime.class) {
            implementGameLogic(challenge, game);
            memcache.put(gameID, game);
        }

        //Schedule the next task for running, only if there are active players:
        if (game.getQueuedPlayers().size() != 0 || game.getWaitingPlayers().size() != 0 || game.getActivePlayers().size() != 0) {
            final Queue queue = QueueFactory.getDefaultQueue();
            RuntimeRequest runtimeRequest = RuntimeRequest.newBuilder()
                    .setChallengeID(challengeID)
                    .setGameID(game.getId())
                    .setAdminKey(DBManager.adminKey.get().getId())
                    .build();

            TaskOptions taskOptions = TaskOptions.Builder
                    .withUrl("/admin/runtime")
                    .payload(runtimeRequest.toByteArray())
                    .countdownMillis(ONE_SECOND)
                    .method(TaskOptions.Method.POST);
            queue.add(taskOptions);
        }


        System.out.println("OK");
        return RuntimeResponse.newBuilder()
                .setStatus(RuntimeResponse.Status.OK)
                .setMessage("OK")
                .build();
    }

    private void implementGameLogic(final Challenge challenge, final Game game) {
        final long startTime = System.currentTimeMillis();

//        System.out.println("game.getQueuedPlayers() = " + game.getQueuedPlayers());
//        System.out.println("game.getActivePlayers() = " + game.getActivePlayers());
//        System.out.println("game.getWaitingPlayers() = " + game.getWaitingPlayers());

        final Grid grid = challenge.getGrid();

        // check if we can upgrade any players from 'waiting' to 'queued'
        final Vector<String> waitingPlayerIDs = new Vector<>(game.getWaitingPlayers());
        for(final String waitingPlayerId : waitingPlayerIDs) {
            final String code = (String) memcache.get(KeyUtils.getCodeKey(challenge.getId(), waitingPlayerId));
            if (code != null) {
                game.queuePlayerById(waitingPlayerId);
            }
        }

        // now check if we can upgrade any players from 'queued' to 'active'
        while(game.getActivePlayers().size() < challenge.getMaxActivePlayers() && !game.getQueuedPlayers().isEmpty()) {
            game.activateNextPlayer(grid);
        }

        // prepare active players
        final Map<String, MazeSolver> playerIDsToMazeSolvers = new HashMap<>();
        final List<String> activePlayerIDs = game.getActivePlayers();

        for(final String activePlayerId : activePlayerIDs) {
            final String code = (String) memcache.get(KeyUtils.getCodeKey(challenge.getId(), activePlayerId));

//            System.out.println("code = " + code);

            final MazeSolver mazeSolver = new InterpretedMazeSolver(challenge, game, activePlayerId, code);
            mazeSolver.init(challenge, game);
            final byte [] state = (byte[]) memcache.get(getMazeSolverStateKey(game.getId(), activePlayerId));
            mazeSolver.setState(state);
            playerIDsToMazeSolvers.put(activePlayerId, mazeSolver);
        }

        //Optimize: ... consider revising to make multi-threaded and with deadlines? [e.g. check out: com.google.appengine.api.ThreadManager]
        RuntimeController.makeMove(challenge, game, playerIDsToMazeSolvers);

        // store maze solvers' state to memcache
        for(final String activePlayerId : activePlayerIDs) {
            final MazeSolver mazeSolver = playerIDsToMazeSolvers.get(activePlayerId);
            memcache.put(getMazeSolverStateKey(game.getId(), activePlayerId), mazeSolver.getState());
        }

        //Publish the state to all connected channels:
        for (String activePlayerID : game.getAllPlayers().keySet()) {
            AMCWorldSession worldSession = game.getPlayerWorldSessions().get(activePlayerID);
            Channel channel = ably.channels.get("stateUpdate-" + activePlayerID);
            try {

                //Compose state:
                final List<PickableEntity> pickables = game.getPickables();
                final Map<String, PlayerEntity> playerEntities = game.getPlayerEntities();

                final AMCPartialStateProto.Builder builder = AMCPartialStateProto.newBuilder();

                //Pickable entities:
                for (PickableEntity pickable : pickables) {
                    builder.putEntities(pickable.getId(), pickable.toGenericProto().build());
                }

                //Player entities:
                for (Map.Entry<String, PlayerEntity> entry : playerEntities.entrySet()) {
                    builder.putEntities(entry.getKey(), entry.getValue().toGenericProto().build());
                }

                //Players:
                for (Map.Entry<String, AMCPlayer> entry : game.getAllPlayers().entrySet()) {
                    builder.putPlayers(entry.getKey(), entry.getValue().toProto().build());
                }

                //World sessions:
                for (Map.Entry<String, AMCWorldSession> entry : game.getPlayerWorldSessions().entrySet()) {
                    builder.putWorldSessions(entry.getKey(), entry.getValue().toProto().build());
                }

                //Handle events:
                final HashMap<Long, Audio> playerEvents = game.getPlayerEvents(worldSession.getPlayerID());
                Vector<Audio> dispatchedEvents = new Vector<>(playerEvents.values());
                game.clearAllPlayerEvents(worldSession.getPlayerID());
                memcache.put(game.getId(), game);

                //Retrieve the partial state:
                builder
                        .setTimestamp(System.currentTimeMillis())
                        .setWorldSession(worldSession.toProto())
                        .setGrid(grid.toProto()) //Optimize: Perhaps not necessary to include the grid, since its state does not change?
                        .addAllActivePlayers(game.getActivePlayers())
                        .addAllQueuedPlayers(game.getQueuedPlayers())
                        .addAllWaitingPlayers(game.getWaitingPlayers())
                        .build();

                final UpdateStateResponse updateStateResponse = UpdateStateResponse.newBuilder()
                        .setStatus(UpdateStateResponse.Status.OK)
                        .setMessage("OK")
                        .setStateUpdate(AMCStateUpdateProto.newBuilder()
                                .setPartialState(builder.build())
                                .setTimestamp(System.currentTimeMillis())
                                .setWorldSessionID(worldSession.getId())
                                .addAllEvents(dispatchedEvents)
                                .build()
                        )
                        .build();


                //Send message:
                channel.publish("stateUpdate", updateStateResponse.toByteArray());

            } catch (AblyException e) {
                e.printStackTrace();
            }
        }

        // remove completed players (move from 'active' to 'finished')
        final MatrixPosition targetPosition = challenge.getGrid().getTargetPosition();
        Vector<String> playersToDeactivate = new Vector<>();

        for(final String activePlayerId : activePlayerIDs) {
            final MatrixPosition playerPosition = game.getPlayerEntities().get(activePlayerId + "_" + game.getPlayerWorldSessions().get(activePlayerId).getWorldID()).getPosition();
            // for any players that were moved in 'inactive' status, reset their state and code so they are not restarted automatically
            if(playerPosition != null && playerPosition.equals(targetPosition)) {
                playersToDeactivate.add(activePlayerId);
                game.addPlayerEvent(activePlayerId, Audio.EVENT_WIN_Audio); //NEW 2.0 (Online events)
            }
        }

        for (String playerID : playersToDeactivate) {
            memcache.delete(getMazeSolverStateKey(game.getId(), playerID)); // reset algorithm's state
            memcache.delete(KeyUtils.getCodeKey(challenge.getId(), playerID)); // reset submitted code
            game.resetPlayerById(playerID);
            memcache.put(game.getId(), game);

            //Update state:
            for (String activePlayerID : game.getAllPlayers().keySet()) {
                AMCWorldSession worldSession = game.getPlayerWorldSessions().get(activePlayerID);
                Channel channel = ably.channels.get("stateUpdate-" + activePlayerID);
                try {

                    //Compose state:
                    final List<PickableEntity> pickables = game.getPickables();
                    final Map<String, PlayerEntity> playerEntities = game.getPlayerEntities();

                    final AMCPartialStateProto.Builder builder = AMCPartialStateProto.newBuilder();

                    //Pickable entities:
                    for (PickableEntity pickable : pickables) {
                        builder.putEntities(pickable.getId(), pickable.toGenericProto().build());
                    }

                    //Player entities:
                    for (Map.Entry<String, PlayerEntity> entry : playerEntities.entrySet()) {
                        builder.putEntities(entry.getKey(), entry.getValue().toGenericProto().build());
                    }

                    //Players:
                    for (Map.Entry<String, AMCPlayer> entry : game.getAllPlayers().entrySet()) {
                        builder.putPlayers(entry.getKey(), entry.getValue().toProto().build());
                    }

                    //World sessions:
                    for (Map.Entry<String, AMCWorldSession> entry : game.getPlayerWorldSessions().entrySet()) {
                        builder.putWorldSessions(entry.getKey(), entry.getValue().toProto().build());
                    }

                    //Handle events:
                    final HashMap<Long, Audio> playerEvents = game.getPlayerEvents(worldSession.getPlayerID());
                    Vector<Audio> dispatchedEvents = new Vector<>(playerEvents.values());
                    game.clearAllPlayerEvents(worldSession.getPlayerID());

                    //Retrieve the partial state:
                    builder
                            .setTimestamp(System.currentTimeMillis())
                            .setWorldSession(worldSession.toProto())
                            .setGrid(grid.toProto()) //Optimize: Perhaps not necessary to include the grid, since its state does not change?
                            .addAllActivePlayers(game.getActivePlayers())
                            .addAllQueuedPlayers(game.getQueuedPlayers())
                            .addAllWaitingPlayers(game.getWaitingPlayers())
                            .build();

                    final UpdateStateResponse updateStateResponse = UpdateStateResponse.newBuilder()
                            .setStatus(UpdateStateResponse.Status.OK)
                            .setMessage("OK")
                            .setStateUpdate(AMCStateUpdateProto.newBuilder()
                                    .setPartialState(builder.build())
                                    .setTimestamp(System.currentTimeMillis())
                                    .setWorldSessionID(worldSession.getId())
                                    .addAllEvents(dispatchedEvents)
                                    .build()
                            )
                            .build();


                    //Send message:
                    channel.publish("stateUpdate", updateStateResponse.toByteArray());

                } catch (AblyException e) {
                    e.printStackTrace();
                }
            }
        }

        long latency = System.currentTimeMillis() - startTime;
        game.addStateUpdateLatency(latency);

        // update game with number of rounds executed
        game.touch(System.currentTimeMillis() - startTime);
        System.out.println("Game: " + game.getId() + "\nRound: " + game.getCounter());
    }

    public static String getMazeSolverStateKey(final String gameId, final String playerId) {
        return "cached-maze-solver-state-" + gameId + "-" + playerId;
    }
    
}

